npm init -y=> initializes a new nodejs project by creating package.json
package.json =>contains dependencies(package ur appln will need like express,nodemon etc)

framework is like a pre-built toolbox for coding that gives you a structured way to build applications faster. Express is a framework for Node.js that simplifies creating web servers, just like React helps build user interfaces easily

Express is a fast and lightweight web framework for Node.js (which lets you run JavaScript on a server). It helps you build websites and backend services easily.

Node.js is a JavaScript runtime that lets you run JavaScript code outside a web browser (like on a server). It’s built on Chrome’s V8 engine (the same one that powers Google Chrome) and makes JavaScript fast and efficient for backend development. With Node.js, you can build web servers, APIs, real-time apps (like chats), and more—all using JavaScript, the language you already know from frontend web dev!

A server is like a powerful, always-on computer that stores data, runs apps, and delivers information to other devices (like your phone or laptop) when requested. For example, when you visit a website, a web server sends the site’s files to your browser. Servers handle tasks in the background—hosting websites, managing databases, or running APIs—so users can access services smoothly.

bcrypt: Encrypts passwords securely so they can't be stolen from your database.
cookie-parser: Reads cookies from browsers to handle user sessions easily.
dotenv: Loads secrets (like API keys) from a .env file so they stay private.
express: The core framework for building your Node.js web server/app.
jsonwebtoken: Creates secure login tokens (JWT) for user authentication.
mongoose: Lets your Node.js app talk to MongoDB (a NoSQL database) easily.
nodemailer: Sends emails (like password resets) from your Node.js app.
nodemon: Auto-restarts your server when you save code (dev-only).
otp-generator: Generates one-time passwords (OTPs) for SMS/email verification.

git add .  =>Pick all my changed files and get them ready.
git commit -m "your message here" =>Save these changes with a note about what I did
git push  =>Send my saved work to the online project (like GitHub).

//check if its correct=>line 102 of Auth.js

=====================================================================
1. User Requests to Buy a Course
A user wants to buy a course on your platform.
The user clicks "Buy Now".
2. Backend Creates Razorpay Order
Your server gets the course details (price, name, etc.) and the user's details (like userId).
Your server creates an order by calling Razorpay API with the payment details (like amount, currency, receipt, notes, etc.)
Razorpay API Call: instance.orders.create(options)
3. Razorpay Returns Payment Order
Razorpay creates the order and sends a response back to your server, which includes:
orderId (a unique ID for the transaction)
currency and amount
Your server logs the response and then sends this information (including course details) to the frontend.
4. Frontend Shows Payment Widget
The frontend (client-side) receives the orderId and other payment details.
Razorpay's payment widget opens on the user's screen to allow them to enter payment details (credit/debit card, UPI, etc.).
5. User Makes Payment
The user enters payment details in the Razorpay widget.
Razorpay processes the payment and confirms whether the payment is successful or failed.
6. Razorpay Sends Payment Status (Webhook or Callback)
Once the payment is processed, Razorpay sends a callback or a webhook to your server with:
paymentId
orderId
paymentStatus (success or failure)
Other details like receipt, userId, etc.
7. Backend Verifies Payment
Your backend receives the payment details via the webhook.
It verifies the payment status.
If payment is successful: You enroll the user in the course.
If payment is failed: You handle failure, such as sending a message to the user.
8. Frontend Shows Payment Success/Failure
Based on the response from the server, the frontend shows:
Success: “Payment Successful! You are now enrolled in the course.”
Failure: “Payment Failed! Please try again.”

========================================================================

Sign Up: User submits credentials, server hashes the password with bcrypt, and stores the hash in the database.user password is converted into a long string with some salt factor now this long string is saved in db and this string can not be reconverted back to password again
Sign In: User submits credentials, server hashes the entered password and compares it with the stored hash.the same password is again converted to same long string as stored in db and then both long string are matched to check if password is correct or not.
If the password matches, the server generates a JWT (containing user info) and sends it to the client.it is made using jwt.sign fn
The client stores the JWT (in localStorage or cookies) and sends it with requests in the Authorization header.
The server verifies the JWT on each request to ensure it's valid and not expired.
If the JWT is valid, the server processes the request (e.g., fetching user data).
If the JWT expires, the server returns a 401 Unauthorized error.

====================================================================
You are a teacher. You give a signed note to a student that says:
"This student is allowed to enter the class – Signed by Teacher"
This note is like a JWT token. Now when the student comes back to class, they show the note.
You don’t need to remember every note you gave. You just check:
Is this note signed by me?
Is it still valid (not expired)?
If both are true, you trust the note.
Now in code:
When user logs in, you create a token using:
jwt.sign(payload, secret)
This adds a digital signature using your secret key.
Later, when user sends that token, you do:
jwt.verify(token, secret)
It checks:
Was the token really signed with your secret?
Is the token not expired?
If both are true → token is valid.
If someone fakes the token → the signature won’t match → token is rejected.
======================================================================
1. Encryption
What it does: Changes data into unreadable form using a key.
Can be reversed? Yes, using the same (or matching) key.
Use case: Protecting messages, files, or any data you want to get back later.
Example: Encrypt a file, then decrypt it to read again.
Symmetric encryption: Same key to encrypt & decrypt.
Asymmetric encryption: Public key to encrypt, private key to decrypt.
2. Bcrypt (Hashing) eg -sha256
What it does: Converts data (like a password) into a fixed-length, random-looking string.
Can be reversed? No – it’s one-way.
Use case: Storing passwords safely so even the server can’t read them.
Example: Password 123456 becomes something like $2b$10$Xs3...

====================================================

hmac=hash based message authentication code=hash+secret key

=============================================================

Go to MongoDB Atlas and log in.
Click on the project where you already have Cluster0.
On the dashboard, click on "Cluster0" (or your active cluster).
Click “Browse Collections” (this opens the database/collection area).
Click the “Create Database” button.
Fill the form:
Database Name: study_notion
Collection Name: e.g., users or anything (you can change it later)
Click “Create” — the study_notion database is now created.
2. Get the Connection String
In the Cluster0 view, click the “Connect” button (top-right).
Choose “Connect your application”.
Set:Driver: Node.js
Copy the given connection string:
===================================================
Not your Gmail password,,Google blocks less secure apps, so you need to generate an app password.
==========================================================

1. Store:The store is like a big JavaScript object where your entire app’s important data lives. It's the central brain of your application.In an e-commerce site like Flipkart:
The store may hold:
User login info
Cart items
Product filters
Theme (dark/light mode)
This way, every component (Navbar, Cart page, Home page) can access or update this data easily.
2. State:The state is the actual data inside the store. Think of it as the current snapshot of everything.
In a course platform:
user: { name: 'Prakhar', isLoggedIn: true }
cart: [course1, course2]
isDarkMode: false
Each time you log in, add a course, or switch theme, this state changes.
3. Actions
An action is a plain object that describes what should happen. It doesn't change the data — just tells the app what kind of update is needed.
When you click "Add to Cart":
Action: { type: 'ADD_TO_CART', payload: courseId }
When you click "Logout":
Action: { type: 'LOGOUT' }
These actions are then sent to reducers to handle.
4. Reducers:Reducers are functions that take the current state and an action, and return the new updated state.
When the ADD_TO_CART action is sent, the reducer adds the course to the cart array.
When the LOGOUT action is sent, the reducer resets the user state.
Reducers are like state editors. They decide how data should change.
5. Dispatch:Dispatch is a function you use to send an action to the reducer.
You click a button → dispatch({ type: 'TOGGLE_THEME' })
Dispatch passes this action to reducer → reducer updates theme state → UI changes
Without dispatch, the reducer doesn’t know when to run.
6. Selector:A selector is used to read data from the store.
In the Navbar, you show the number of items in the cart:
Use a selector to get state.cart.length
In the footer, you show if the user is logged in:
Use selector to get state.user.isLoggedIn
You use selectors in components to display current values from the store.
=============================================================================
A. State
State is the actual data that stores current theme.

In our case:
theme: 'light' or theme: 'dark'

This is part of the central Redux store and can be read by any component (Header, Body, Footer, etc.).

🔸 B. Store
Store holds the full app state, including this theme.

Example store might look like:

js
Copy
Edit
{
  theme: 'dark',
  user: { name: 'Prakhar', loggedIn: true },
  cart: []
}
It’s the single source of truth for the whole app.

🔸 C. Action
An action is a signal that says:
"I want to change the theme."

It might look like:
{ type: 'TOGGLE_THEME' }

This action tells the reducer:
“Hey, flip the theme to the opposite of current.”

🔸 D. Reducer
The reducer gets the action and updates the theme.

It checks:
If theme is light → change to dark
If theme is dark → change to light

Reducer only returns the new state, it never modifies the old one directly.

🔸 E. Dispatch
You call dispatch(action) to tell Redux to change the state.

When user clicks the toggle button → you dispatch({ type: 'TOGGLE_THEME' })

Redux then sends this action to the reducer.

Dispatch is like triggering an event.

🔸 F. Selector
Components use selectors to read the current theme.

For example:

The background color of a page depends on the theme.

The moon or sun icon shows based on the theme.

Selector lets components access:
state.theme and update their style or logic accordingly.
=======================================================
A slice in Redux Toolkit is a collection of:A small piece of state
The reducers that handle it
The actions to update it
It bundles all related logic (state + reducers + actions) into one file — which is much cleaner and easier than traditional Redux.
🔸 Real-Life Analogy
Imagine your app as a house:
Theme slice is the switchboard that controls light/dark mode
Other slices might control:
User slice – login/logout
Cart slice – add/remove items
Course slice – fetch courses
Each slice controls one part of the house, but all connect to the main control panel (store).
🔹 Theme Slice (Dark/Light Toggle Example)
Let’s break this into the same Redux parts — but inside a slice:
1. State
Inside the theme slice, we define:
initialState: { mode: 'light' }
This becomes part of the Redux store under state.theme.mode.
2. Reducers
We define a reducer inside the slice:
toggleTheme: (state) => {
  state.mode = state.mode === 'light' ? 'dark' : 'light';
}
This handles the toggle action.
You don’t need to write action types manually.

3. Actions
Redux Toolkit automatically creates actions for your reducers.
For toggleTheme, it auto-generates an action:
{ type: 'theme/toggleTheme' }
No need to manually write this.
4. Dispatch
In your component, when the user clicks the toggle button:
dispatch(toggleTheme())
This triggers the reducer defined in the slice.
5. Selector
You use useSelector to read the value:
const mode = useSelector(state => state.theme.mode)
This lets your components change their look based on the current theme.
====================================================
Then Why Use Redux for Theme?
You use Redux only if:

1. Multiple Components need to know the theme
Navbar, Footer, Body, Sidebar, etc.

All of them need to know current theme and change styles accordingly.

Without Redux, you'd have to pass props down or use Context, which can get messy.

2. You want to save the theme globally and maybe even persist it
Example: When a user reloads the page, the theme stays the same

You can connect Redux with localStorage easily

Redux state can be reused across routes and pages
